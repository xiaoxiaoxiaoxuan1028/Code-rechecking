# Code-rechecking
String comparison - Longest common subsequence based on dynamic programming

##一、实验目的：
使用动态规划中最长公共子序列的基本思想实现对代码的查重

##二、实现思想：
对于这个问题，我的基本思想是将代码中的每一行进行比较，分别求出每一行的最长公共子序列数，然后将统计出的所有最长公共子序列数除以整个代码的总字符数，即为代码的重复率，这里将两个代码中的一个代码作为基准代码，将另一个作为比较代码，然后将比较代码中的一行与基准代码中的每一行执行最长公共子序列算法，。
对于字符的预处理，首先头文件肯定不需要进行比较，因为即使两个完全不一样的代码，它们的头文件也是有极大可能是一样的。其次就是标点符号的问题，我想过去掉所有标点，但是最后还是只去掉了句末的分号、句中的所有空格。最重要的是去掉注释，因为对于注释，它的存在会极大地影响代码查重的准确率，所以应该将它们全部去掉，这里要考虑”//“和“/*“两种注释

##三、实验内容
1、	设定重复率的度量方式：本代码以语句的重复度来衡量两代码的重复度，即相同或相似的子句占总代码长度的比例越高，两代码的重复度就越高。
2、	设定计算子句相似度的算法：利用LCS最长公共子序列算法来计算子句的相似度，即两语句中相似的部分越多，两语句的相似度就越高。
3、	实现代码中无关语句的剔除：在比较两代码重复度前，一些代码中共同存在的部分要剔除，以免虚高重复度。排除了注释、变量类型、基本语句、标点符号、空格、换行等其他无关因素对代码重复度的影响。
4、	合理计算重复度：设定合理的计算机制来将子句相似度转换成代码的相似度。
5、	对计算出的重复度进行检验分析：将测试的多组代码进行查重，分析比较得出的相似度是否符合实际情况，然后针对结果优化查重算法。

##四、实验过程：
（1）	具体代码：（这里将不同的代码块进行分别说明—具体注释已经在代码中给出）
//Delete函数（字符串预处理函数）（部分）
在这个函数中，主要运用了string类，主要是find，erase，length，empty等
 
//readinfile函数（文件读入并存入字符串数组）
 
//CompareInLine函数（DP求解最长公共子序列）具有最优子结构性质->递推公式
 
//Calculate函数（求解代码重复率）--在这个函数中主要统计比较代码的总字符数
 
//main函数（主要将比较代码中的一行与基准代码中的每一行代码进行比较）

（2）时间复杂性分析
因为使用两代码的每一行进行比较，所以执行lcs算法的次数大约为2*h1*h2次，lcs算法的时间复杂度为O（L1i+L2j），所以总的时间复杂度为O（2*h1*h2*（L1i+L2j））；使用lcs算法额外需要的空间为O（L1*L2），其中L1和L2分别为代码1和代码2中最长行的长度。

##五、实验心得
在进行了一系列优化之后，本查重程序可以良好的达到设计的目的，经过重复测试，代码重复度在80%以上的代码基本可以直接判定为抄袭，重复度在80%到35%的代码存在借鉴或算法思路大致相同且编程习惯相似所导致的偶然性，重复度在35%以下的代码基本可以认定是由不同个体原创实现。
在本次实验中，最重要的算法思想就是DP算法中的最长公共子序列问题，对一个文件反复运用最长公共子序列即可求解。问题的关键是，应该将什么执行最长公共子序列，是整个文件，还是文件的某一部分。
本次实验仍然存在需要改进的不足之处，因为互不相关的代码的重复率也很高，毫不相关的代码也可能被判定为抄袭，所以还应该想出一个更好的策略来解决该问题。我对于改进的想法是，运用深度学习，让计算机首先识别出这两个代码是不是在解决同一个问题，如果是，则进行比较，如果不是，则输出，这两个代码可能不是在解决同一个问题。
	
